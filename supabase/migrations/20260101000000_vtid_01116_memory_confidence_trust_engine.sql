-- Migration: 20260101000000_vtid_01116_memory_confidence_trust_engine.sql
-- Purpose: VTID-01116 Memory Confidence & Source Trust Engine
-- Date: 2026-01-02
--
-- Introduces a deterministic confidence and trust model for all memory items
-- so ORB knows how much to trust what it remembers.
--
-- Core Components:
--   1. Source Classification with Trust Weights
--   2. Confidence Score Model (0-100) per memory item
--   3. Confidence Adjustment Rules (deterministic)
--   4. Confidence History Tracking for Explainability
--   5. Safety & Sensitivity Handling
--
-- Dependencies:
--   - VTID-01104 (memory_items)
--   - VTID-01101 (tenant/user helpers)
--   - VTID-01100 (quality metrics - integration point)

-- ===========================================================================
-- 1. SOURCE CLASSIFICATION & TRUST WEIGHTS
-- ===========================================================================

-- Source types with their maximum trust weights
-- Source type affects the MAXIMUM confidence a memory can achieve
CREATE TABLE IF NOT EXISTS public.memory_source_trust (
    source_type TEXT PRIMARY KEY,
    trust_weight INT NOT NULL CHECK (trust_weight >= 0 AND trust_weight <= 100),
    max_confidence INT NOT NULL CHECK (max_confidence >= 0 AND max_confidence <= 100),
    label TEXT NOT NULL,
    description TEXT,
    requires_validation BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Seed source trust weights per spec Section 3
-- User-stated (explicit) has highest trust, derived/computed has lowest
INSERT INTO public.memory_source_trust (source_type, trust_weight, max_confidence, label, description, requires_validation) VALUES
    ('user_explicit', 100, 95, 'User Stated (Explicit)', 'User directly stated or confirmed this information', false),
    ('user_inferred', 70, 80, 'User Inferred (Implicit)', 'Inferred from user behavior or context', false),
    ('diary', 90, 90, 'Diary Entry', 'From user diary entries - high personal trust', false),
    ('orb_text', 75, 85, 'ORB Text Input', 'From ORB chat text conversations', false),
    ('orb_voice', 70, 80, 'ORB Voice Input', 'From ORB voice transcription (may have errors)', false),
    ('upload', 60, 75, 'User Upload', 'From uploaded files or documents', true),
    ('system', 50, 70, 'System Generated', 'Auto-generated by the system', false),
    ('third_party', 40, 65, 'Third Party', 'From labs, wearables, external services', true),
    ('derived', 30, 60, 'Derived/Computed', 'Computed or derived from other memories', false)
ON CONFLICT (source_type) DO UPDATE SET
    trust_weight = EXCLUDED.trust_weight,
    max_confidence = EXCLUDED.max_confidence,
    label = EXCLUDED.label,
    description = EXCLUDED.description,
    requires_validation = EXCLUDED.requires_validation;

-- ===========================================================================
-- 2. CONFIDENCE ADJUSTMENT REASON CODES
-- ===========================================================================

-- Deterministic reason codes for confidence adjustments (Section 5)
CREATE TABLE IF NOT EXISTS public.memory_confidence_reasons (
    reason_code TEXT PRIMARY KEY,
    category TEXT NOT NULL CHECK (category IN ('increase', 'decrease', 'neutral')),
    delta_min INT NOT NULL,
    delta_max INT NOT NULL,
    label TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Seed adjustment reason codes per spec Section 5
INSERT INTO public.memory_confidence_reasons (reason_code, category, delta_min, delta_max, label, description) VALUES
    -- Increase reasons
    ('USER_CONFIRMED', 'increase', 5, 15, 'User Confirmation', 'User explicitly confirmed this memory is accurate'),
    ('REPETITION_CONSISTENT', 'increase', 3, 8, 'Repetition Consistency', 'Memory was mentioned consistently multiple times'),
    ('CROSS_REFERENCE_MATCH', 'increase', 2, 5, 'Cross-Reference Match', 'Matches information from another trusted source'),
    ('PROFESSIONAL_VERIFIED', 'increase', 10, 20, 'Professional Verification', 'Verified by a healthcare professional or expert'),
    ('LAB_CONFIRMED', 'increase', 15, 25, 'Lab Confirmation', 'Confirmed by lab results or medical records'),

    -- Decrease reasons
    ('USER_CORRECTED', 'decrease', -20, -10, 'User Correction', 'User corrected this memory - trust permanently reduced'),
    ('CONTRADICTING_EVIDENCE', 'decrease', -15, -5, 'Contradicting Evidence', 'New information contradicts this memory'),
    ('TIME_DECAY', 'decrease', -5, -1, 'Time Decay', 'Soft confidence decay over time without reconfirmation'),
    ('SOURCE_INVALIDATED', 'decrease', -30, -15, 'Source Invalidated', 'The source of this memory was found unreliable'),
    ('PARTIAL_RETRACTION', 'decrease', -10, -5, 'Partial Retraction', 'User indicated parts of this memory are inaccurate'),

    -- Neutral reasons
    ('INITIAL_CAPTURE', 'neutral', 0, 0, 'Initial Capture', 'Initial confidence set at memory creation'),
    ('RECALCULATED', 'neutral', 0, 0, 'Recalculated', 'Confidence recalculated due to rule changes'),
    ('SENSITIVITY_CAP', 'neutral', 0, 0, 'Sensitivity Cap', 'Confidence capped due to sensitivity classification')
ON CONFLICT (reason_code) DO UPDATE SET
    category = EXCLUDED.category,
    delta_min = EXCLUDED.delta_min,
    delta_max = EXCLUDED.delta_max,
    label = EXCLUDED.label,
    description = EXCLUDED.description;

-- ===========================================================================
-- 3. EXTEND MEMORY_ITEMS WITH CONFIDENCE FIELDS
-- ===========================================================================

-- Add confidence scoring columns to memory_items
-- These columns enable per-item trust evaluation

-- confidence_score: 0-100, how much ORB trusts this memory
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS confidence_score INT NOT NULL DEFAULT 50
CHECK (confidence_score >= 0 AND confidence_score <= 100);

-- source_classification: Normalized source type for trust weighting
-- Maps the existing 'source' column to the new source trust classification
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS source_classification TEXT DEFAULT 'system'
REFERENCES public.memory_source_trust(source_type);

-- verification_level: How verified is this memory?
-- none, user_confirmed, cross_referenced, professionally_verified, lab_confirmed
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS verification_level TEXT NOT NULL DEFAULT 'none'
CHECK (verification_level IN ('none', 'user_confirmed', 'cross_referenced', 'professionally_verified', 'lab_confirmed'));

-- sensitivity_flag: Is this memory sensitive (medical/psychological)?
-- Affects maximum confidence per spec Section 8
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS sensitivity_flag TEXT DEFAULT NULL
CHECK (sensitivity_flag IS NULL OR sensitivity_flag IN ('medical', 'psychological', 'financial', 'legal', 'personal'));

-- third_party_source: For third-party data, track the source name
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS third_party_source TEXT DEFAULT NULL;

-- third_party_valid: For third-party data, is the source currently valid?
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS third_party_valid BOOLEAN DEFAULT NULL;

-- last_confidence_update: When was confidence last adjusted?
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS last_confidence_update TIMESTAMPTZ DEFAULT NOW();

-- times_confirmed: How many times has user confirmed this memory?
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS times_confirmed INT NOT NULL DEFAULT 0;

-- times_corrected: How many times has user corrected this memory?
-- Higher correction count = permanently lower trust
ALTER TABLE public.memory_items
ADD COLUMN IF NOT EXISTS times_corrected INT NOT NULL DEFAULT 0;

-- Index for confidence-based queries
CREATE INDEX IF NOT EXISTS idx_memory_items_confidence
    ON public.memory_items (tenant_id, user_id, confidence_score DESC);

CREATE INDEX IF NOT EXISTS idx_memory_items_source_classification
    ON public.memory_items (tenant_id, user_id, source_classification);

-- ===========================================================================
-- 4. CONFIDENCE HISTORY TRACKING (AUDIT TRAIL)
-- ===========================================================================

-- Track all confidence changes for explainability (Section 9)
CREATE TABLE IF NOT EXISTS public.memory_confidence_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    user_id UUID NOT NULL,
    memory_item_id UUID NOT NULL REFERENCES public.memory_items(id) ON DELETE CASCADE,

    -- Confidence change details
    previous_confidence INT NOT NULL,
    new_confidence INT NOT NULL,
    delta INT NOT NULL,

    -- Reason tracking
    reason_code TEXT NOT NULL REFERENCES public.memory_confidence_reasons(reason_code),
    reason_details JSONB DEFAULT '{}',

    -- Actor tracking
    triggered_by TEXT NOT NULL CHECK (triggered_by IN ('user', 'system', 'professional', 'third_party', 'time_decay')),
    triggered_by_user_id UUID DEFAULT NULL,

    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for efficient history queries
CREATE INDEX IF NOT EXISTS idx_memory_confidence_history_memory
    ON public.memory_confidence_history (memory_item_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_memory_confidence_history_tenant_user
    ON public.memory_confidence_history (tenant_id, user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_memory_confidence_history_reason
    ON public.memory_confidence_history (reason_code, created_at DESC);

-- ===========================================================================
-- 5. RLS POLICIES
-- ===========================================================================

-- Enable RLS on new tables
ALTER TABLE public.memory_source_trust ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.memory_confidence_reasons ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.memory_confidence_history ENABLE ROW LEVEL SECURITY;

-- memory_source_trust: Read-only lookup table (public)
DROP POLICY IF EXISTS memory_source_trust_select ON public.memory_source_trust;
CREATE POLICY memory_source_trust_select ON public.memory_source_trust
    FOR SELECT
    TO authenticated
    USING (true);

-- memory_confidence_reasons: Read-only lookup table (public)
DROP POLICY IF EXISTS memory_confidence_reasons_select ON public.memory_confidence_reasons;
CREATE POLICY memory_confidence_reasons_select ON public.memory_confidence_reasons
    FOR SELECT
    TO authenticated
    USING (true);

-- memory_confidence_history: User can view their own history
DROP POLICY IF EXISTS memory_confidence_history_select ON public.memory_confidence_history;
CREATE POLICY memory_confidence_history_select ON public.memory_confidence_history
    FOR SELECT
    TO authenticated
    USING (
        tenant_id = public.current_tenant_id()
        AND user_id = auth.uid()
    );

-- memory_confidence_history: Insert via SECURITY DEFINER functions only
DROP POLICY IF EXISTS memory_confidence_history_insert ON public.memory_confidence_history;
CREATE POLICY memory_confidence_history_insert ON public.memory_confidence_history
    FOR INSERT
    TO authenticated
    WITH CHECK (
        tenant_id = public.current_tenant_id()
        AND user_id = auth.uid()
    );

-- ===========================================================================
-- 6. HELPER FUNCTIONS
-- ===========================================================================

-- Function to map legacy source types to new source classification
CREATE OR REPLACE FUNCTION public.memory_map_source_classification(p_source TEXT)
RETURNS TEXT
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
    RETURN CASE p_source
        WHEN 'orb_text' THEN 'orb_text'
        WHEN 'orb_voice' THEN 'orb_voice'
        WHEN 'diary' THEN 'diary'
        WHEN 'upload' THEN 'upload'
        WHEN 'system' THEN 'system'
        ELSE 'system'
    END;
END;
$$;

-- Function to compute initial confidence based on source type
-- Deterministic: Same source + verification = same initial confidence
CREATE OR REPLACE FUNCTION public.memory_compute_initial_confidence(
    p_source_classification TEXT,
    p_verification_level TEXT DEFAULT 'none',
    p_sensitivity_flag TEXT DEFAULT NULL
)
RETURNS INT
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
    v_base_trust INT;
    v_max_confidence INT;
    v_verification_bonus INT;
    v_sensitivity_cap INT;
    v_confidence INT;
BEGIN
    -- Get base trust weight and max confidence for source type
    SELECT trust_weight, max_confidence
    INTO v_base_trust, v_max_confidence
    FROM public.memory_source_trust
    WHERE source_type = p_source_classification;

    -- Default if source not found
    IF v_base_trust IS NULL THEN
        v_base_trust := 50;
        v_max_confidence := 70;
    END IF;

    -- Calculate verification bonus (deterministic)
    v_verification_bonus := CASE p_verification_level
        WHEN 'lab_confirmed' THEN 20
        WHEN 'professionally_verified' THEN 15
        WHEN 'cross_referenced' THEN 10
        WHEN 'user_confirmed' THEN 5
        ELSE 0
    END;

    -- Calculate sensitivity cap (Section 8)
    -- Medical/psychological memories capped below max
    v_sensitivity_cap := CASE p_sensitivity_flag
        WHEN 'medical' THEN 75
        WHEN 'psychological' THEN 70
        WHEN 'financial' THEN 80
        WHEN 'legal' THEN 75
        ELSE 100
    END;

    -- Compute confidence: base_trust + verification_bonus, capped by max and sensitivity
    v_confidence := LEAST(
        v_base_trust + v_verification_bonus,
        v_max_confidence,
        v_sensitivity_cap
    );

    -- Enforce hard constraint: No automatic promotion to 100 (Section 5)
    IF v_confidence >= 100 THEN
        v_confidence := 95;
    END IF;

    RETURN v_confidence;
END;
$$;

-- Function to calculate confidence adjustment delta (deterministic)
CREATE OR REPLACE FUNCTION public.memory_calculate_adjustment_delta(
    p_reason_code TEXT,
    p_current_confidence INT,
    p_context JSONB DEFAULT '{}'
)
RETURNS INT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_reason RECORD;
    v_delta INT;
    v_repetition_count INT;
    v_correction_count INT;
BEGIN
    -- Get reason code details
    SELECT * INTO v_reason
    FROM public.memory_confidence_reasons
    WHERE reason_code = p_reason_code;

    IF v_reason IS NULL THEN
        RETURN 0;
    END IF;

    -- Deterministic delta calculation based on reason and context
    -- Same inputs always produce same outputs (Section 7)

    CASE p_reason_code
        WHEN 'USER_CONFIRMED' THEN
            -- Diminishing returns on confirmations
            v_repetition_count := COALESCE((p_context->>'times_confirmed')::INT, 0);
            v_delta := GREATEST(v_reason.delta_min, v_reason.delta_max - (v_repetition_count * 2));

        WHEN 'USER_CORRECTED' THEN
            -- Corrections have permanent impact, scaled by correction count
            v_correction_count := COALESCE((p_context->>'times_corrected')::INT, 0);
            v_delta := v_reason.delta_min - (v_correction_count * 3); -- Gets worse with each correction

        WHEN 'TIME_DECAY' THEN
            -- Soft decay based on days since last update
            DECLARE
                v_days_since_update INT;
            BEGIN
                v_days_since_update := COALESCE((p_context->>'days_since_update')::INT, 0);
                -- Decay 1 point per 30 days, max 5 points
                v_delta := -1 * LEAST(5, FLOOR(v_days_since_update / 30.0)::INT);
                -- Don't decay if recently confirmed
                IF v_days_since_update < 30 THEN
                    v_delta := 0;
                END IF;
            END;

        WHEN 'REPETITION_CONSISTENT' THEN
            -- Consistent mention increases trust, but capped
            v_repetition_count := COALESCE((p_context->>'consistent_mentions')::INT, 1);
            v_delta := LEAST(v_reason.delta_max, v_reason.delta_min + v_repetition_count);

        WHEN 'CONTRADICTING_EVIDENCE' THEN
            -- Contradiction severity affects delta
            DECLARE
                v_severity TEXT;
            BEGIN
                v_severity := COALESCE(p_context->>'severity', 'minor');
                v_delta := CASE v_severity
                    WHEN 'major' THEN v_reason.delta_min
                    WHEN 'moderate' THEN (v_reason.delta_min + v_reason.delta_max) / 2
                    ELSE v_reason.delta_max
                END;
            END;

        ELSE
            -- Default: use middle of range
            v_delta := (v_reason.delta_min + v_reason.delta_max) / 2;
    END CASE;

    RETURN v_delta;
END;
$$;

-- ===========================================================================
-- 7. CORE RPC FUNCTIONS
-- ===========================================================================

-- RPC: Adjust confidence for a memory item
CREATE OR REPLACE FUNCTION public.memory_adjust_confidence(
    p_memory_item_id UUID,
    p_reason_code TEXT,
    p_context JSONB DEFAULT '{}'
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tenant_id UUID;
    v_user_id UUID;
    v_memory RECORD;
    v_delta INT;
    v_new_confidence INT;
    v_max_confidence INT;
    v_sensitivity_cap INT;
BEGIN
    -- Derive tenant_id from context
    v_tenant_id := public.current_tenant_id();
    IF v_tenant_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'TENANT_NOT_FOUND',
            'message', 'Unable to determine tenant_id from request context'
        );
    END IF;

    -- Derive user_id from auth
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'UNAUTHENTICATED',
            'message', 'No authenticated user'
        );
    END IF;

    -- Get the memory item
    SELECT * INTO v_memory
    FROM public.memory_items
    WHERE id = p_memory_item_id
      AND tenant_id = v_tenant_id
      AND user_id = v_user_id;

    IF v_memory IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'MEMORY_NOT_FOUND',
            'message', 'Memory item not found or access denied'
        );
    END IF;

    -- Validate reason code
    IF NOT EXISTS (SELECT 1 FROM public.memory_confidence_reasons WHERE reason_code = p_reason_code) THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'INVALID_REASON_CODE',
            'message', 'Reason code does not exist'
        );
    END IF;

    -- Calculate delta (deterministic)
    v_delta := public.memory_calculate_adjustment_delta(
        p_reason_code,
        v_memory.confidence_score,
        p_context || jsonb_build_object(
            'times_confirmed', v_memory.times_confirmed,
            'times_corrected', v_memory.times_corrected
        )
    );

    -- Get max confidence for source
    SELECT max_confidence INTO v_max_confidence
    FROM public.memory_source_trust
    WHERE source_type = v_memory.source_classification;

    v_max_confidence := COALESCE(v_max_confidence, 70);

    -- Apply sensitivity cap if applicable
    v_sensitivity_cap := CASE v_memory.sensitivity_flag
        WHEN 'medical' THEN 75
        WHEN 'psychological' THEN 70
        ELSE 100
    END;

    -- Calculate new confidence with bounds
    v_new_confidence := GREATEST(0, LEAST(
        v_memory.confidence_score + v_delta,
        v_max_confidence,
        v_sensitivity_cap,
        95 -- Hard cap: no automatic promotion to 100
    ));

    -- Log to history before update
    INSERT INTO public.memory_confidence_history (
        tenant_id,
        user_id,
        memory_item_id,
        previous_confidence,
        new_confidence,
        delta,
        reason_code,
        reason_details,
        triggered_by,
        triggered_by_user_id
    ) VALUES (
        v_tenant_id,
        v_user_id,
        p_memory_item_id,
        v_memory.confidence_score,
        v_new_confidence,
        v_delta,
        p_reason_code,
        p_context,
        COALESCE(p_context->>'triggered_by', 'user'),
        v_user_id
    );

    -- Update the memory item
    UPDATE public.memory_items
    SET
        confidence_score = v_new_confidence,
        last_confidence_update = NOW(),
        times_confirmed = CASE
            WHEN p_reason_code = 'USER_CONFIRMED' THEN times_confirmed + 1
            ELSE times_confirmed
        END,
        times_corrected = CASE
            WHEN p_reason_code = 'USER_CORRECTED' THEN times_corrected + 1
            ELSE times_corrected
        END
    WHERE id = p_memory_item_id;

    RETURN jsonb_build_object(
        'ok', true,
        'memory_item_id', p_memory_item_id,
        'previous_confidence', v_memory.confidence_score,
        'new_confidence', v_new_confidence,
        'delta', v_delta,
        'reason_code', p_reason_code,
        'capped_by', CASE
            WHEN v_new_confidence = 95 THEN 'hard_cap'
            WHEN v_new_confidence = v_sensitivity_cap AND v_sensitivity_cap < 100 THEN 'sensitivity'
            WHEN v_new_confidence = v_max_confidence THEN 'source_max'
            ELSE NULL
        END
    );
END;
$$;

-- RPC: User confirms a memory (convenience wrapper)
CREATE OR REPLACE FUNCTION public.memory_confirm_item(
    p_memory_item_id UUID,
    p_confirmation_notes TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN public.memory_adjust_confidence(
        p_memory_item_id,
        'USER_CONFIRMED',
        jsonb_build_object(
            'triggered_by', 'user',
            'confirmation_notes', p_confirmation_notes
        )
    );
END;
$$;

-- RPC: User corrects a memory (convenience wrapper)
CREATE OR REPLACE FUNCTION public.memory_correct_item(
    p_memory_item_id UUID,
    p_correction_notes TEXT DEFAULT NULL,
    p_new_content TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_result JSONB;
BEGIN
    -- Adjust confidence first
    v_result := public.memory_adjust_confidence(
        p_memory_item_id,
        'USER_CORRECTED',
        jsonb_build_object(
            'triggered_by', 'user',
            'correction_notes', p_correction_notes,
            'had_content_update', p_new_content IS NOT NULL
        )
    );

    -- If correction includes new content, update it
    IF p_new_content IS NOT NULL AND (v_result->>'ok')::BOOLEAN THEN
        UPDATE public.memory_items
        SET content = p_new_content
        WHERE id = p_memory_item_id;

        v_result := v_result || jsonb_build_object('content_updated', true);
    END IF;

    RETURN v_result;
END;
$$;

-- RPC: Get confidence history for a memory item
CREATE OR REPLACE FUNCTION public.memory_get_confidence_history(
    p_memory_item_id UUID,
    p_limit INT DEFAULT 50
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tenant_id UUID;
    v_user_id UUID;
    v_history JSONB;
    v_memory RECORD;
BEGIN
    -- Derive tenant_id from context
    v_tenant_id := public.current_tenant_id();
    IF v_tenant_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'TENANT_NOT_FOUND'
        );
    END IF;

    -- Derive user_id from auth
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'UNAUTHENTICATED'
        );
    END IF;

    -- Get current memory item state
    SELECT id, confidence_score, source_classification, verification_level,
           sensitivity_flag, times_confirmed, times_corrected, created_at
    INTO v_memory
    FROM public.memory_items
    WHERE id = p_memory_item_id
      AND tenant_id = v_tenant_id
      AND user_id = v_user_id;

    IF v_memory IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'MEMORY_NOT_FOUND'
        );
    END IF;

    -- Get history entries
    SELECT COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', h.id,
                'previous_confidence', h.previous_confidence,
                'new_confidence', h.new_confidence,
                'delta', h.delta,
                'reason_code', h.reason_code,
                'reason_label', r.label,
                'reason_details', h.reason_details,
                'triggered_by', h.triggered_by,
                'created_at', h.created_at
            )
            ORDER BY h.created_at DESC
        ),
        '[]'::JSONB
    )
    INTO v_history
    FROM public.memory_confidence_history h
    LEFT JOIN public.memory_confidence_reasons r ON r.reason_code = h.reason_code
    WHERE h.memory_item_id = p_memory_item_id
      AND h.tenant_id = v_tenant_id
      AND h.user_id = v_user_id
    LIMIT p_limit;

    RETURN jsonb_build_object(
        'ok', true,
        'memory_item_id', p_memory_item_id,
        'current_state', jsonb_build_object(
            'confidence_score', v_memory.confidence_score,
            'source_classification', v_memory.source_classification,
            'verification_level', v_memory.verification_level,
            'sensitivity_flag', v_memory.sensitivity_flag,
            'times_confirmed', v_memory.times_confirmed,
            'times_corrected', v_memory.times_corrected,
            'memory_created_at', v_memory.created_at
        ),
        'history', v_history,
        'history_count', jsonb_array_length(v_history)
    );
END;
$$;

-- RPC: Get memories with confidence filtering (for context assembly)
CREATE OR REPLACE FUNCTION public.memory_get_context_with_confidence(
    p_limit INT DEFAULT 20,
    p_min_confidence INT DEFAULT 0,
    p_categories TEXT[] DEFAULT NULL,
    p_since TIMESTAMPTZ DEFAULT NULL,
    p_include_low_confidence BOOLEAN DEFAULT false
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tenant_id UUID;
    v_user_id UUID;
    v_items JSONB;
    v_effective_min INT;
BEGIN
    -- Derive tenant_id from context
    v_tenant_id := public.current_tenant_id();
    IF v_tenant_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'TENANT_NOT_FOUND'
        );
    END IF;

    -- Derive user_id from auth
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'UNAUTHENTICATED'
        );
    END IF;

    -- Enforce hard constraint: Low-confidence memory may not dominate context (Section 6)
    -- Unless explicitly requested, filter out low confidence items
    v_effective_min := CASE
        WHEN p_include_low_confidence THEN p_min_confidence
        ELSE GREATEST(p_min_confidence, 30) -- Default minimum 30 for context
    END;

    -- Cap limit to reasonable bounds
    IF p_limit IS NULL OR p_limit < 1 THEN
        p_limit := 20;
    ELSIF p_limit > 100 THEN
        p_limit := 100;
    END IF;

    -- Query memory items with confidence weighting
    -- Higher confidence items are prioritized (relevance scoring integration)
    SELECT COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', mi.id,
                'category_key', mi.category_key,
                'source', mi.source,
                'source_classification', mi.source_classification,
                'content', mi.content,
                'occurred_at', mi.occurred_at,
                'importance', mi.importance,
                'confidence_score', mi.confidence_score,
                'verification_level', mi.verification_level,
                'sensitivity_flag', mi.sensitivity_flag,
                'times_confirmed', mi.times_confirmed,
                'times_corrected', mi.times_corrected,
                -- Computed relevance score combining importance and confidence
                'relevance_score', ROUND((mi.importance * 0.4 + mi.confidence_score * 0.6)::NUMERIC, 2)
            )
            ORDER BY
                -- Prioritize by combined relevance score
                (mi.importance * 0.4 + mi.confidence_score * 0.6) DESC,
                mi.occurred_at DESC
        ),
        '[]'::JSONB
    )
    INTO v_items
    FROM public.memory_items mi
    WHERE mi.tenant_id = v_tenant_id
      AND mi.user_id = v_user_id
      AND mi.confidence_score >= v_effective_min
      AND (p_categories IS NULL OR mi.category_key = ANY(p_categories))
      AND (p_since IS NULL OR mi.occurred_at >= p_since)
    LIMIT p_limit;

    RETURN jsonb_build_object(
        'ok', true,
        'items', v_items,
        'filters', jsonb_build_object(
            'min_confidence', v_effective_min,
            'categories', p_categories,
            'since', p_since,
            'include_low_confidence', p_include_low_confidence
        ),
        'count', jsonb_array_length(v_items)
    );
END;
$$;

-- RPC: Apply time decay to all memories (batch operation for scheduled job)
CREATE OR REPLACE FUNCTION public.memory_apply_time_decay(
    p_decay_threshold_days INT DEFAULT 30
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tenant_id UUID;
    v_user_id UUID;
    v_decayed_count INT := 0;
    v_memory RECORD;
    v_delta INT;
    v_new_confidence INT;
BEGIN
    -- Derive tenant_id from context
    v_tenant_id := public.current_tenant_id();
    IF v_tenant_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'TENANT_NOT_FOUND'
        );
    END IF;

    -- Derive user_id from auth
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'error', 'UNAUTHENTICATED'
        );
    END IF;

    -- Process memories that haven't been updated in threshold days
    FOR v_memory IN
        SELECT id, confidence_score, last_confidence_update
        FROM public.memory_items
        WHERE tenant_id = v_tenant_id
          AND user_id = v_user_id
          AND last_confidence_update < NOW() - (p_decay_threshold_days || ' days')::INTERVAL
          AND confidence_score > 10 -- Don't decay already very low confidence
    LOOP
        -- Calculate days since last update
        DECLARE
            v_days_since INT := EXTRACT(DAY FROM NOW() - v_memory.last_confidence_update)::INT;
        BEGIN
            v_delta := public.memory_calculate_adjustment_delta(
                'TIME_DECAY',
                v_memory.confidence_score,
                jsonb_build_object('days_since_update', v_days_since)
            );

            IF v_delta < 0 THEN
                v_new_confidence := GREATEST(10, v_memory.confidence_score + v_delta);

                -- Log to history
                INSERT INTO public.memory_confidence_history (
                    tenant_id,
                    user_id,
                    memory_item_id,
                    previous_confidence,
                    new_confidence,
                    delta,
                    reason_code,
                    reason_details,
                    triggered_by
                ) VALUES (
                    v_tenant_id,
                    v_user_id,
                    v_memory.id,
                    v_memory.confidence_score,
                    v_new_confidence,
                    v_delta,
                    'TIME_DECAY',
                    jsonb_build_object('days_since_update', v_days_since),
                    'time_decay'
                );

                -- Update the memory
                UPDATE public.memory_items
                SET
                    confidence_score = v_new_confidence,
                    last_confidence_update = NOW()
                WHERE id = v_memory.id;

                v_decayed_count := v_decayed_count + 1;
            END IF;
        END;
    END LOOP;

    RETURN jsonb_build_object(
        'ok', true,
        'decayed_count', v_decayed_count,
        'threshold_days', p_decay_threshold_days
    );
END;
$$;

-- ===========================================================================
-- 8. TRIGGER: Auto-set initial confidence on memory insert
-- ===========================================================================

CREATE OR REPLACE FUNCTION public.memory_set_initial_confidence()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Map source to source_classification if not set
    IF NEW.source_classification IS NULL THEN
        NEW.source_classification := public.memory_map_source_classification(NEW.source);
    END IF;

    -- Calculate initial confidence if not explicitly set or if using default
    IF NEW.confidence_score = 50 THEN -- Default value indicates not explicitly set
        NEW.confidence_score := public.memory_compute_initial_confidence(
            NEW.source_classification,
            NEW.verification_level,
            NEW.sensitivity_flag
        );
    END IF;

    -- Set last_confidence_update
    NEW.last_confidence_update := NOW();

    RETURN NEW;
END;
$$;

-- Create trigger (drop first if exists)
DROP TRIGGER IF EXISTS trigger_memory_set_initial_confidence ON public.memory_items;
CREATE TRIGGER trigger_memory_set_initial_confidence
    BEFORE INSERT ON public.memory_items
    FOR EACH ROW
    EXECUTE FUNCTION public.memory_set_initial_confidence();

-- ===========================================================================
-- 9. TRIGGER: Log confidence changes to history on update
-- ===========================================================================

CREATE OR REPLACE FUNCTION public.memory_log_confidence_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Only log if confidence actually changed
    IF OLD.confidence_score != NEW.confidence_score THEN
        -- Check if this was already logged by an RPC function
        -- (look for recent history entry within last second)
        IF NOT EXISTS (
            SELECT 1 FROM public.memory_confidence_history
            WHERE memory_item_id = NEW.id
              AND created_at > NOW() - INTERVAL '1 second'
        ) THEN
            INSERT INTO public.memory_confidence_history (
                tenant_id,
                user_id,
                memory_item_id,
                previous_confidence,
                new_confidence,
                delta,
                reason_code,
                reason_details,
                triggered_by
            ) VALUES (
                NEW.tenant_id,
                NEW.user_id,
                NEW.id,
                OLD.confidence_score,
                NEW.confidence_score,
                NEW.confidence_score - OLD.confidence_score,
                'RECALCULATED',
                jsonb_build_object('trigger', 'direct_update'),
                'system'
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$;

-- Create trigger (drop first if exists)
DROP TRIGGER IF EXISTS trigger_memory_log_confidence_change ON public.memory_items;
CREATE TRIGGER trigger_memory_log_confidence_change
    AFTER UPDATE ON public.memory_items
    FOR EACH ROW
    EXECUTE FUNCTION public.memory_log_confidence_change();

-- ===========================================================================
-- 10. MIGRATE EXISTING DATA
-- ===========================================================================

-- Backfill source_classification for existing memory items
UPDATE public.memory_items
SET source_classification = public.memory_map_source_classification(source)
WHERE source_classification IS NULL OR source_classification = 'system';

-- Recalculate confidence for existing items that have default confidence
UPDATE public.memory_items
SET confidence_score = public.memory_compute_initial_confidence(
    source_classification,
    verification_level,
    sensitivity_flag
),
last_confidence_update = NOW()
WHERE confidence_score = 50; -- Only update items with default confidence

-- ===========================================================================
-- 11. PERMISSIONS
-- ===========================================================================

-- RPC functions: callable by authenticated users
GRANT EXECUTE ON FUNCTION public.memory_map_source_classification(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_compute_initial_confidence(TEXT, TEXT, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_calculate_adjustment_delta(TEXT, INT, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_adjust_confidence(UUID, TEXT, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_confirm_item(UUID, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_correct_item(UUID, TEXT, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_get_confidence_history(UUID, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_get_context_with_confidence(INT, INT, TEXT[], TIMESTAMPTZ, BOOLEAN) TO authenticated;
GRANT EXECUTE ON FUNCTION public.memory_apply_time_decay(INT) TO authenticated;

-- Tables: allow authenticated users to interact (RLS will enforce row-level access)
GRANT SELECT ON public.memory_source_trust TO authenticated;
GRANT SELECT ON public.memory_confidence_reasons TO authenticated;
GRANT SELECT, INSERT ON public.memory_confidence_history TO authenticated;

-- ===========================================================================
-- 12. COMMENTS (DOCUMENTATION)
-- ===========================================================================

COMMENT ON TABLE public.memory_source_trust IS 'VTID-01116: Source classification with trust weights for memory confidence scoring';
COMMENT ON TABLE public.memory_confidence_reasons IS 'VTID-01116: Deterministic reason codes for confidence adjustments';
COMMENT ON TABLE public.memory_confidence_history IS 'VTID-01116: Audit trail of all confidence changes for explainability';

COMMENT ON COLUMN public.memory_items.confidence_score IS 'VTID-01116: Trust score 0-100, how much ORB trusts this memory';
COMMENT ON COLUMN public.memory_items.source_classification IS 'VTID-01116: Normalized source type for trust weighting';
COMMENT ON COLUMN public.memory_items.verification_level IS 'VTID-01116: Level of verification (none, user_confirmed, cross_referenced, professionally_verified, lab_confirmed)';
COMMENT ON COLUMN public.memory_items.sensitivity_flag IS 'VTID-01116: Sensitivity classification affecting max confidence (medical, psychological, financial, legal, personal)';
COMMENT ON COLUMN public.memory_items.times_confirmed IS 'VTID-01116: Number of times user confirmed this memory';
COMMENT ON COLUMN public.memory_items.times_corrected IS 'VTID-01116: Number of times user corrected this memory (affects trust permanently)';

COMMENT ON FUNCTION public.memory_adjust_confidence IS 'VTID-01116: Adjust confidence for a memory item with reason tracking';
COMMENT ON FUNCTION public.memory_confirm_item IS 'VTID-01116: User confirms a memory, increasing confidence';
COMMENT ON FUNCTION public.memory_correct_item IS 'VTID-01116: User corrects a memory, permanently reducing trust';
COMMENT ON FUNCTION public.memory_get_confidence_history IS 'VTID-01116: Get confidence history for explainability';
COMMENT ON FUNCTION public.memory_get_context_with_confidence IS 'VTID-01116: Get memory context with confidence filtering for D23 integration';
COMMENT ON FUNCTION public.memory_apply_time_decay IS 'VTID-01116: Apply soft time decay to memories (batch operation)';

-- ===========================================================================
-- End of VTID-01116 Migration
-- ===========================================================================
